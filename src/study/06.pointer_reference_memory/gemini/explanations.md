### 실습 1: 포인터, 레퍼런스, 변수 핵심 개념 퀴즈

아래 코드에는 정답 코드 한 줄과 네 개의 오답 코드가 주석 처리되어 있습니다. 주석을 하나씩 해제하고 코드를 실행하여, 어떤 코드가 올바르게 동작하는지 확인해 보세요.

**문제:** `int` 변수 `a`의 주소를 `ptr`이라는 이름의 `int` 포인터 변수에 저장하는 코드는?

```cpp
#include <iostream>

int main() {
    int a = 10;
    int* ptr = nullptr;

    std::cout << "변수 a의 주소: " << &a << std::endl;

    // TODO: 아래 5개의 코드 중 정답 코드를 찾아 주석을 해제하고 실행해 보세요.

    // 오답 1: 포인터에 변수의 값을 직접 대입 (타입 불일치)
    // ptr = a;

    // 오답 2: 포인터에 주소 연산자 없이 변수를 대입 (타입 불일치)
    // ptr = a;

    // 오답 3: 포인터에 역참조 연산자를 사용하여 변수의 값을 대입 (잘못된 연산)
    // *ptr = a;

    // 정답: 포인터에 변수의 주소(&a)를 대입
    // ptr = &a;

    // 오답 4: 포인터가 가리키는 값에 주소 연산자를 사용하여 대입 (잘못된 연산)
    // *ptr = &a;

    // 정답 코드를 해제한 후, 포인터와 변수의 관계를 확인해 보세요.
    if (ptr != nullptr) {
        std::cout << "포인터 ptr이 저장한 주소: " << ptr << std::endl;
        std::cout << "포인터 ptr을 통해 접근한 a의 값: " << *ptr << std::endl;
    }

    return 0;
}
```

**설명:**

  * **`ptr = &a;`** 가 정답입니다. 포인터는 변수의 **주소**를 저장하므로, 변수 `a`의 주소를 나타내는 `&a`를 포인터 `ptr`에 대입해야 합니다.
  * **`ptr = a;`** 와 같은 코드는 `int` 타입의 값을 `int*` 타입의 변수에 대입하려 하므로, 컴파일 에러를 발생시킵니다.
  * **`*ptr = a;`** 와 같은 코드는 `ptr`이 가리키는 메모리 공간에 `a`의 값을 대입하라는 의미이지만, `ptr`은 초기화되지 않은 상태(`nullptr`)이므로 런타임 오류를 유발합니다.

-----

### **실습 2: 포인터, 레퍼런스, 변수를 사용한 출력**

아래 코드는 변수, 포인터, 레퍼런스 중 어떤 방식을 사용하느냐에 따라 다른 문장이 출력되도록 구성되어 있습니다.

**목표 문장:**
"저는 50의 값과 0x7fff... 주소를 가진 변수입니다."

`TODO` 부분을 올바른 코드로 채워 목표 문장이 출력되도록 만들어 보세요.

```cpp
#include <iostream>
#include <string>

int main() {
    int value = 50;
    int* ptr_to_value = &value;
    int& ref_to_value = value;

    std::cout << "아래 문장 중 목표 문장과 일치하도록 TODO를 수정하세요." << std::endl;
    std::cout << "목표 문장: '저는 50의 값과 0x7fff... 주소를 가진 변수입니다.'" << std::endl;
    std::cout << "---------------------------------------------------------" << std::endl;

    // TODO: 아래 if-else if-else 문을 수정하여 목표 문장이 출력되도록 코드를 작성하세요.
    if (false /* 변수를 사용한 경우 */) {
        std::cout << "저는 " << value << "의 값과 " << &value << " 주소를 가진 변수입니다." << std::endl;
    } 
    else if (false /* 포인터를 사용한 경우 */) {
        std::cout << "저는 " << *ptr_to_value << "의 값과 " << ptr_to_value << " 주소를 가진 포인터입니다." << std::endl;
    }
    else if (true /* 레퍼런스를 사용한 경우 */) {
        std::cout << "저는 " << ref_to_value << "의 값과 " << &ref_to_value << " 주소를 가진 변수입니다." << std::endl;
    }
    else {
        std::cout << "올바른 방식이 아닙니다." << std::endl;
    }
    
    std::cout << "---------------------------------------------------------" << std::endl;
    std::cout << "정답 코드를 찾았나요? \n변수, 포인터, 레퍼런스가 메모리 주소와 값을 어떻게 다루는지 잘 이해하면 정답을 찾을 수 있을 겁니다!" << std::endl;

    return 0;
}
```

**정답 및 해설:**
목표 문장은 "변수"의 관점에서 값을 출력하고 있습니다.

1.  `if (true /* 변수를 사용한 경우 */)` 부분의 조건문을 `true`로 변경하고, `else if` 문들의 조건을 `false`로 변경하면 목표 문장이 출력됩니다.
2.  `std::cout << "저는 " << value << "의 값과 " << &value << " 주소를 가진 변수입니다." << std::endl;` 이 정답입니다.
      * `value`는 변수 **자체의 값**을 의미합니다.
      * `&value`는 변수의 **주소**를 의미합니다.
3.  `else if (false /* 포인터를 사용한 경우 */)` 부분은 `*ptr_to_value`를 사용해 값을 출력하지만, 포인터가 저장하고 있는 주소는 `ptr_to_value` 자체이므로 "포인터입니다"라는 문장이 더 자연스럽습니다.
4.  `else if (true /* 레퍼런스를 사용한 경우 */)` 부분도 정답처럼 보일 수 있지만, `ref_to_value`는 `value`의 별칭일 뿐이므로, `&ref_to_value`는 `&value`와 동일한 주소를 반환합니다. 따라서 레퍼런스를 통해 `value`의 값과 주소를 출력하는 것도 정답에 해당합니다. 하지만 문제의 의도는 변수, 포인터, 레퍼런스의 역할을 구분하는 것이므로, 가장 직관적으로 '변수'의 관점에서 출력하는 첫 번째 `if` 문이 더 적절합니다.

이 실습을 통해 변수, 포인터, 레퍼런스가 각각 값과 주소를 어떻게 표현하고 있는지 명확하게 이해할 수 있습니다.