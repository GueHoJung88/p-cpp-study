# C++ 포인터와 레퍼런스 학습 자료

## 1. 변수, 포인터, 레퍼런스의 관계

변수는 메모리 상의 특정 위치에 할당되어 값을 저장하는 공간입니다. 포인터는 변수의 메모리 주소를 값으로 가지는 특별한 변수입니다. 레퍼런스는 이미 존재하는 변수에 대한 또 다른 이름 (별칭)입니다.

* **변수:**
    * 메모리 주소: `0x123`
    * 값: `100`
    * 표현: `int Var1 = 100;`

* **포인터:**
    * 메모리 주소: `0x155`
    * 값 (가리키는 주소): `0x123`
    * 표현: `int* ptr = &Var1;`
    * **도식화:**
        ![포인터 도식화 예시](/asset\image\passing-addresses-to-functions-in-c.webp)

* **변수:**
    * 메모리 주소: `2000`
    * 값: `10`
    * 표현: `int a = 10;`
* **레퍼런스:**
    * 메모리 주소: `2000` (원본 변수와 동일)
    * 값: `10` (원본 변수와 동일)
    * 표현: `int& b = a;`
    * **도식화:**
       ![레퍼런스 도식화 예시](/asset\image\references-in-cpp.webp)

**기억할 점:**

* 포인터는 **별도의 메모리 공간**을 차지하며, 변수의 주소를 저장합니다. 포인터를 통해 변수의 값을 간접적으로 조작할 수 있습니다 (`*` 연산자 사용).
* 레퍼런스는 **새로운 메모리 공간을 할당받지 않으며**, 선언 시 반드시 초기화되어야 합니다. 레퍼런스는 원본 변수의 또 다른 이름처럼 동작하며, 레퍼런스를 통한 조작은 원본 변수에 직접적인 영향을 줍니다.
* 변수는 실제 값을 저장하는 메모리 공간입니다. `&` 연산자를 사용하여 변수의 메모리 주소를 얻을 수 있습니다.

## 2. 동적 메모리 관리

정적 메모리 할당은 컴파일 시간에 메모리 크기가 결정되고 프로그램 실행 동안 그 크기가 변하지 않는 방식입니다 (예: 지역 변수, 전역 변수, 배열 등). 반면, 동적 메모리 할당은 프로그램 실행 중에 필요한 만큼의 메모리를 운영체제로부터 요청하여 사용하는 방식입니다. C++에서는 `new` 연산자와 `delete` 연산자를 사용하여 동적 메모리 관리를 수행합니다.

### `new` 연산자:

* `new` 연산자는 힙(heap)이라는 메모리 영역에서 요청한 크기의 메모리 블록을 할당하고, 그 메모리 블록의 **시작 주소**를 반환합니다.
* 단일 객체를 위한 메모리 할당: `데이터타입* 포인터변수 = new 데이터타입;`
    * 예: `int* dynamic_int = new int;` (정수형 데이터를 저장할 메모리 공간 할당)
* 배열을 위한 메모리 할당: `데이터타입* 포인터변수 = new 데이터타입 [크기];`
    * 예: `int* dynamic_array = new int [10];` (정수형 데이터 10개를 저장할 배열 공간 할당)
* `new` 연산자는 메모리 할당에 실패하면 예외(`std::bad_alloc`)를 발생시킬 수 있습니다.

### `delete` 연산자:

* `new` 연산자로 동적으로 할당된 메모리는 더 이상 사용하지 않을 때 반드시 `delete` 연산자를 사용하여 해제해야 합니다. 이를 **메모리 누수(memory leak)** 방지라고 합니다.
* 단일 객체 메모리 해제: `delete 포인터변수;`
    * 예: `delete dynamic_int;`
* 배열 메모리 해제: `delete[] 포인터변수;` (**주의:** 배열을 할당할 때는 `delete[]`를 사용해야 합니다. 단순히 `delete`를 사용하면 예기치 않은 오류가 발생할 수 있습니다.)
    * 예: `delete[] dynamic_array;`
* `delete` 연산자를 이미 해제된 메모리 주소에 대해 다시 호출하거나 (double free), `new`로 할당하지 않은 메모리 주소에 대해 호출하는 것은 **정의되지 않은 동작(undefined behavior)**이며, 프로그램 충돌과 같은 심각한 오류를 일으킬 수 있습니다.

### 동적 메모리 관리의 중요성:

* **유연성:** 프로그램 실행 중에 필요한 만큼의 메모리를 할당하고 해제할 수 있어, 프로그램의 요구 사항 변화에 유연하게 대처할 수 있습니다.
* **효율성:** 더 이상 사용하지 않는 메모리를 명시적으로 해제함으로써 메모리 자원을 효율적으로 관리할 수 있습니다.
* **동적 자료 구조 구현:** 연결 리스트, 트리 등 크기가 동적으로 변할 수 있는 자료 구조를 구현하는 데 필수적입니다.

### 기억할 점:

* `new`로 할당된 메모리는 반드시 `delete` 또는 `delete[]`로 해제해야 합니다.
* 메모리 누수를 방지하는 것은 C++ 프로그래밍에서 매우 중요합니다.
* 스마트 포인터 (`std::unique_ptr`, `std::shared_ptr`)는 동적 할당된 메모리의 자동 해제를 제공하여 메모리 관리를 더 안전하고 쉽게 만들어줍니다 (추후 학습).

## 3. 추가 학습 자료

### 실습 1 : 포인터, 레퍼런스, 변수 핵심 개념 퀴즈
아래 코드에는 정답 코드 한 줄과 네 개의 오답 코드가 주석 처리되어 있습니다. 주석을 하나씩 해제하고 코드를 실행하여, 어떤 코드가 올바르게 동작하는지 확인해 보세요.

**문제**: int 변수 a의 주소를 ptr이라는 이름의 int 포인터 변수에 저장하는 코드는?
```cpp
#include <iostream>

int main() {
    int a = 10;
    int* ptr = nullptr;

    std::cout << "변수 a의 주소: " << &a << std::endl;

    // TODO: 아래 5개의 코드 중 정답 코드를 찾아 주석을 해제하고 실행해 보세요.

    // 1: 포인터에 변수의 값을 직접 대입 (타입 불일치)
    // ptr = a;

    // 2: 포인터에 주소 연산자 없이 변수를 대입 (타입 불일치)
    // ptr = a;

    // 3: 포인터에 역참조 연산자를 사용하여 변수의 값을 대입 (잘못된 연산)
    // *ptr = a;

    // 4: 포인터에 변수의 주소(&a)를 대입
    // ptr = &a;

    // 5: 포인터가 가리키는 값에 주소 연산자를 사용하여 대입 (잘못된 연산)
    // *ptr = &a;

    // 정답 코드를 해제한 후, 포인터와 변수의 관계를 확인해 보세요.
    if (ptr != nullptr) {
        std::cout << "포인터 ptr이 저장한 주소: " << ptr << std::endl;
        std::cout << "포인터 ptr을 통해 접근한 a의 값: " << *ptr << std::endl;
    }

    return 0;
}
```

### 실습2 : 포인터, 레퍼런스, 변수를 사용한 출력
아래 코드는 변수, 포인터, 레퍼런스 중 어떤 방식을 사용하느냐에 따라 다른 문장이 출력되도록 구성되어 있습니다.

**목표 문장**:
"저는 50의 값과 0x7fff... 주소를 가진 변수입니다."

TODO 부분을 올바른 코드로 채워 목표 문장이 출력되도록 만들어 보세요.
```cpp
#include <iostream>
#include <string>

int main() {
    int value = 50;
    int* ptr_to_value = &value;
    int& ref_to_value = value;

    std::cout << "아래 문장 중 목표 문장과 일치하도록 TODO를 수정하세요." << std::endl;
    std::cout << "목표 문장: '저는 50의 값과 0x7fff... 주소를 가진 변수입니다.'" << std::endl;
    std::cout << "---------------------------------------------------------" << std::endl;

    // TODO: 아래 if-else if-else 문을 수정하여 목표 문장이 출력되도록 코드를 작성하세요.
    if (false /* 변수를 사용한 경우 */) {
        std::cout << "저는 " << value << "의 값과 " << &value << " 주소를 가진 변수입니다." << std::endl;
    } 
    else if (false /* 포인터를 사용한 경우 */) {
        std::cout << "저는 " << *ptr_to_value << "의 값과 " << ptr_to_value << " 주소를 가진 포인터입니다." << std::endl;
    }
    else if (true /* 레퍼런스를 사용한 경우 */) {
        std::cout << "저는 " << ref_to_value << "의 값과 " << &ref_to_value << " 주소를 가진 변수입니다." << std::endl;
    }
    else {
        std::cout << "올바른 방식이 아닙니다." << std::endl;
    }
    
    std::cout << "---------------------------------------------------------" << std::endl;
    std::cout << "정답 코드를 찾았나요? \n변수, 포인터, 레퍼런스가 메모리 주소와 값을 어떻게 다루는지 잘 이해하면 정답을 찾을 수 있을 겁니다!" << std::endl;

    return 0;
}
```